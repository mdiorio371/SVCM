---
title: "f2"
output: html_document
date: "2024-05-22"
editor_options: 
  chunk_output_type: console
---

# packages
```{r}
library(tidyverse)
library(data.table)
library(Biostrings)
library(ape)
library(IRanges)
#BiocManager::install("GenomicRanges")
library(GenomicRanges)
library(igraph)

library(pbmcapply)
library(viridis)
library(RColorBrewer)
```


To get an up to date dataset
```{r}

options(timeout = 300)

ncbi_url <- 
    "ftp://ftp.ncbi.nlm.nih.gov"

# Download the refseq file

refseq_file <- 
  sprintf(
    "%s/refseq/bacteria/assembly_summary.txt",
    ncbi_url
    )


refseq <- 
    fread(
        refseq_file, 
        stringsAsFactors = F, 
        quote = "",
        select = c(1,5,6,7,8,11,12,15,16,17,18,19,20)
    ) %>%
  filter(
    assembly_level =="Complete Genome",
    version_status =="latest"
    ) 


# Download the taxonomy file
taxa_file <- 
    sprintf(
        "%s/pub/taxonomy/new_taxdump/new_taxdump.tar.gz",
        ncbi_url
    )

database_dir <- 
    "../data/ncbi_db"
        
taxa_con <- 
    curl_download(
        taxa_file,
        destfile = 
            sprintf(
                "%s/new_taxdump.tar.gz",
                database_dir
            )
    )


 taxonomy <- 
      read_tsv(
          sprintf(
              "%s/rankedlineage.dmp",
              database_dir
          ), 
          col_names = 
              c(
                  "taxid", "name", "s", "g", "f", "o", "c","p", "k", "d"
              ),
          col_types=("i-c-c-c-c-c-c-c-c-c-")
      ) %>% 
      filter(d=="Bacteria")
 
 refseq
 
 taxonomy <- 
   readRDS("data/taxonomy.rds")
 
 
 refseq_taxonomy <- 
  inner_join(
    refseq, taxonomy, by = "taxid"
  )
 
 saveRDS(
   refseq_taxonomy,
   "data/refseq_taxonomy.rds"
 )


```



Select a bacterial species with multiple assemblies

```{r}



saveRDS(refseq_taxonomy, "data/refseq_taxonomy.rds")


rm(refseq_taxonomy)

ncbi_table <- 
  readRDS(
    "data/refseq_taxonomy.rds"
  )

species_name <- 
  "Salmonella_enterica"

  
### prepare directories  

clade_name <- 
  filter(
    ncbi_table, 
    species == 
      sub("_", " ", species_name)
    )%>%
  dplyr::slice(1) %>%
  pull(phylum_clade) %>% gsub(" ", "_", .)

species_variable_names <-
    c(
        "sync_dir", "identity_dir",
        "oriC_dir",
        "alignment_dir", "r_vars_dir", "results_dir", 
        #"disparities_dir",# "c01_dir",
        #"subset_dir",
        #"breakpoint_dir", 
        "prokka_dir"
        #"breakpoint_comparisons_dir", "snp_dir",
        #"kmer_dir", "bd_dir", "plot_dir", "roary_dir",
        #"sync2_dir", "test_dir"
    )

species_dirs <- 
    gsub("_dir", "", species_variable_names)

for (var_name in species_variable_names){
    dir_name <- 
        gsub("_dir", "", var_name)
    full_dir_name <- 
        sprintf(
            "processing/%s/%s/%s", 
            dir_name, clade_name, 
            species_name
        )
    
    assign(
        var_name, 
        full_dir_name
    )
    if (!dir.exists(full_dir_name)){dir.create(full_dir_name, recursive = T)}
}



### take a sample of 200
ncbi_table
  


 species_table <- 
      ncbi_table %>%
      filter(
        species==sub("_", " ", species_name)
      )
 set.seed(123)
 st_sample <- 
   sample(1:nrow(species_table), size =200)
   
 

assembly_table <- 
  pbmclapply(
    1:200,
    function(i){
      #for (i in 1:200){
      assembly_path <- 
        (species_table %>% pull(ftp_path))[i]
      
      fasta_path <- 
        sprintf(
          "%s/%s_genomic.fna.gz",
          assembly_path, 
          gsub(".*/", "", assembly_path)
          )
      
      gff_path <- 
        sprintf(
          "%s/%s_genomic.gff.gz",
          assembly_path,
          gsub(".*/", "", assembly_path)
          )
      
      fna_exists <- 
              file_exists_at_url(fasta_path)
      gff_exists <- 
              file_exists_at_url(gff_path)

      dnaA_table <- 
        dnaA_from_gff(
          gff_path
          )
      if (!fna_exists | !gff_exists){
        position_tib <- 
          tibble( 
            asm_name = 
              basename(assembly_path),
            note = "missing fasta/gff"
                  )
      } else {
        position_tib <-   
          dnaA_sync(fasta_path, dnaA_table, sync_dir)
      }
      
      return(position_tib)
    }
      
  ) %>%
  bind_rows()




## load dnaA files arranged to the OriC

load_arranged_assemblies <- 
  function(species_name, ncbi_table, sync_dir, n = 200){

    
   
     
    
    
    positions <- 
      list()
    #pbmclapply 
    for (i in 1:n){
      
      assembly_path <- 
        (species_table %>% pull(ftp_path))[i]
      
      fasta_path <- 
        sprintf(
          "%s/%s_genomic.fna.gz",
          assembly_path, 
          gsub(".*/", "", assembly_path)
          )
      
      gff_path <- 
        sprintf(
          "%s/%s_genomic.gff.gz",
          assembly_path,
          gsub(".*/", "", assembly_path)
          )
      
      fna_exists <- 
              file_exists_at_url(fasta_path)
      gff_exists <- 
              file_exists_at_url(gff_path)
      
      dnaA_table <- 
        dnaA_from_gff(
          gff_path
          )
      
      positions[[i]] <-   
        dnaA_sync(fasta_path, dnaA_table, sync_dir)
      print(i)
    }
    
    bind_rows(positions)
    
}


bind_rows(positions) %>% count(note)

ncbi_table 
```



```{r}
# Testing 20 Using 20 Genomes
set.seed(123)
genome_subset <- 
  assembly_table %>%
  sample_n(20)

accessions <- 
  genome_subset %>% pull(accession)
```


# Optional for 1 versus all alignment
Find the accession with the highest similarity to all other genomes
```{r}

id_dir <- 
  sprintf("%s/ss20", identity_dir)

if (!dir.exists(id_dir)){dir.create(id_dir)}

species_identities <- 
    get_pairwise_identities(
        sync_dir = sync_dir, 
        id_dir = 
          id_dir, 
        species_table = genome_subset, 
        species_name
    )

sampled_id_table <- 
    species_identities$id_dists %>%
    arrange(Sequence_mean_distance)

species_identities$mash_plot

```


## pairwise alignment

Choose an alignment strategy
All VS all
Ref VS Qry
One VS all
```{r}

#choose the number of genomes for each 

### Pairwise alignments are generated using a pairwsie matrix

All_vs_all_m <- 
  t(combn(accessions, 2)) %>%
  `colnames<-`(c("ref", "qry"))


Refs_vs_Qrys <- 
  expand_grid(
    ref = accessions[1:round(length(accessions)/2)], 
    qry = accessions[(round(length(accessions)/2)+1):length(accessions)]
    )

most_related <- 
  sampled_id_table$Sequence[1]

One_vs_all <- 
  tibble(
    ref = most_related,
    qry = accessions[accessions != most_related]
    ) %>% 
  as.matrix()%>%
  `colnames<-`(c("ref", "qry"))

alignment_dir_ava <- 
  sprintf(
    "%s/all_vs_all", alignment_dir
  )
alignment_dir_rvq <- 
  sprintf(
    "%s/refs_vs_qrys", alignment_dir
  )
alignment_dir_1va <- 
  sprintf(
    "%s/one_vs_all", alignment_dir
  )

strategies <- 
  list(
    "All-vs-All" = list(
    matrix = All_vs_all_m,
    dir = alignment_dir_ava
  ),
  "Ref-vs-Query" = list(
    matrix = Refs_vs_Qrys,
    dir = alignment_dir_rvq
  ),
  "1-vs-All" = list(
    matrix = One_vs_all,
    dir = alignment_dir_1va
  )
)

benchmark_results <- 
  imap_dfr(strategies, function(info, strategy_name) {
  benchmark_alignments(
    genome_matrix = info$matrix,
    delta_dir = info$dir,
    sync_dir = sync_dir,
    strategy_name = strategy_name,
    mc.cores = 6
  )
})


walk(strategies, ~{
  if (!dir.exists(.x$dir)) dir.create(.x$dir, recursive = TRUE)
})

pbmclapply(
  1:3,
  function(i){
    generate_nucmer_commands(
      genome_matrix = All_vs_all_m, delta_dir = alignment_dir_ava, sync_dir
      )[i] %>% system()
  }, mc.cores = 6
)


pbmclapply(
  1:nrow(Refs_vs_Qrys),
  function(i){
    generate_nucmer_commands(
      genome_matrix = Refs_vs_Qrys, delta_dir = alignment_dir_ava, sync_dir
      )[i] %>% system()
  }, mc.cores = 6
)

pbmclapply(
  1:nrow(One_vs_all),
  function(i){
    generate_nucmer_commands(
      genome_matrix = One_vs_all, delta_dir = alignment_dir_ava, sync_dir
      )[i] %>% system()
  }, mc.cores = 6
)

benchmark_ava <- 
  benchmark_alignments(All_vs_all_m, alignment_dir_ava, sync_dir, "All-vs-all")

benchmark_rvq <- 
  benchmark_alignments(Refs_vs_Qrys, alignment_dir_rvq, sync_dir, "Ref-vs-Query")
benchmark_1va <- 
  benchmark_alignments(One_vs_all, alignment_dir_1va, sync_dir, "1-vs-All")


 generate_nucmer_commands(All_vs_all_m, alignment_dir_ava, sync_dir)

 
 genome_matrix <- All_vs_all_m
   delta_dir <- 
     alignment_dir_ava
benchmark_alignments <- 
  function(genome_matrix, delta_dir, sync_dir, strategy_name, mc.cores = 6) {
  

  message("Starting benchmarking: ", strategy_name)

  # Precompute all commands
  cmds <- 
    generate_nucmer_commands(genome_matrix, delta_dir, sync_dir, nuc_remove = F)

  results <- 
    pbmclapply(
      1:nrow(genome_matrix),
      function(i) {
        ref <- genome_matrix[i,1]
        qry <- genome_matrix[i,2]
        pair_id <- paste(ref, qry, sep = "_vs_")
        start_time <- Sys.time()
  
        res <- tryCatch({
          cmd <- cmds[i]
          exit_code <- system(cmd)
          end_time <- Sys.time()
          tibble(
            strategy = strategy_name,
            pair = pair_id,
            ref = ref,
            qry = qry,
            runtime_sec = as.numeric(difftime(end_time, start_time, units = "secs")),
            exit_code = exit_code
          )
        }, error = function(e) {
          message("Error on pair: ", pair_id, " â€” ", e$message)
          tibble(
            strategy = strategy_name,
            pair = pair_id,
            ref = ref,
            qry = qry,
            runtime_sec = NA_real_,
            exit_code = NA_integer_
          )
        })
  
        res
    },
    mc.cores = mc.cores
  )

  # Filter out any unexpected NULLs
  results <- results[!sapply(results, is.null)]

  # Force all elements to be tibbles
  results <- lapply(results, function(x) {
    if (!inherits(x, "data.frame")) {
      tibble(
        strategy = strategy_name,
        pair = NA_character_,
        ref = NA_character_,
        qry = NA_character_,
        runtime_sec = NA_real_,
        exit_code = NA_integer_
      )
    } else {
      x
    }
  })

  bind_rows(results)
}





benchmark_ava <- 
  benchmark_alignments(All_vs_all_m, alignment_dir_ava, sync_dir, "All-vs-All")
benchmark_rvq <- 
  benchmark_alignments(Refs_vs_Qrys, alignment_dir_ava, sync_dir, "Ref-vs-Query")
benchmark_1va <- 
  benchmark_alignments(One_vs_all, alignment_dir_ava, sync_dir, "1-vs-All")

benchmark_rvq <- 
  benchmark_rvq %>%
  mutate(
    ref = as.character(ref$ref),
    qry = as.character(qry$qry)
  )


all_benchmarks <- bind_rows(benchmark_ava, benchmark_rvq, benchmark_1va)

all_benchmarks %>%
  group_by(strategy) %>%
  summarise(
    total_runtime_sec = sum(runtime_sec, na.rm = TRUE),
    mean_runtime_sec = mean(runtime_sec, na.rm = TRUE),
    sd_runtime_sec   = sd(runtime_sec, na.rm = TRUE),
    Alignments          = n(),
  )

library(kableExtra)
all_benchmarks %>%
  group_by(strategy) %>%
  summarise(
    total_runtime_min = sum(runtime_sec, na.rm = TRUE) / 60,
    mean_runtime_sec  = mean(runtime_sec, na.rm = TRUE),
    sd_runtime_sec    = sd(runtime_sec, na.rm = TRUE),
    Alignments        = n()
  ) %>%
  arrange(total_runtime_min) %>%
  dplyr::rename(
    Strategy             = strategy,
    `Total (min)`          = total_runtime_min,
    `Mean (sec)`           = mean_runtime_sec,
    `SD (sec)`             = sd_runtime_sec
  ) %>%
  kbl(
    col.names  = c("Strategy", "Total Runtime (min)", "Mean Runtime (s)", "SD Runtime (s)", "Alignments"),
    digits     = 1,
    format     = "html"
  ) %>%
  kable_styling(
    bootstrap_options = c("condensed", "bordered", "hover"),
        full_width        = FALSE,
        position          = "center",
        font_size         = 12
  ) %>%
  column_spec(1, bold = TRUE) %>%
  add_header_above(c( "Runtime Metrics" = 5)) %>%
   row_spec(0, bold = TRUE, background = "#D3D3D3") 


generate_nucmer_commands(All_vs_all_m, alignment_dir_ava, sync_dir)[1:3]
system(generate_nucmer_commands(All_vs_all_m, alignment_dir_ava, sync_dir)[1])

tibble(
  Component = c("Operating System", "CPU model", "Cores used", 
                "Total RAM (GB)", "R version", "dplyr version", 
                "knitr version", "kableExtra version"),
  Details = c(
    paste(Sys.info()["sysname"], Sys.info()["release"]),
    Sys.info()["machine"],
    parallel::detectCores(logical = FALSE),      # physical cores
    round(as.numeric(
      strsplit(system("sysctl hw.memsize", intern = TRUE), ": ")[[1]][2]
    ) / (1024^3), 1),
    R.version$version.string,
    as.character(packageVersion("dplyr")),
    as.character(packageVersion("knitr")),
    as.character(packageVersion("kableExtra"))
  )
)
env <- tibble(
  Component = c("Operating System", "CPU model", "Cores used", 
                "Total RAM (GB)", "R version", "dplyr version"),
  Details = c(
    paste(Sys.info()["sysname"], Sys.info()["release"]),
    Sys.info()["machine"],
    parallel::detectCores(logical = FALSE),      # physical cores
    round(as.numeric(
      strsplit(system("sysctl hw.memsize", intern = TRUE), ": ")[[1]][2]
    ) / (1024^3), 1),
    R.version$version.string,
    as.character(packageVersion("dplyr"))
  )
)
  env %>%
  kbl(
    caption   = "Table S1: Computational environment for benchmark runs",
    col.names = c("Component", "Details"),
    align     = c("l", "l"),
    format    = "html"
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width        = FALSE,
    position          = "center"
  )

ggplot(all_benchmarks, aes(x = strategy, y = runtime_sec)) +
  geom_boxplot() +
  labs(title = "Runtime per Pairwise Comparison", y = "Time (sec)", x = NULL)

ggplot(all_benchmarks %>% group_by(strategy) %>%
         summarise(total_runtime = sum(runtime_sec, na.rm = TRUE)),
       aes(x = strategy, y = total_runtime)) +
  geom_col() +
  labs(title = "Total Runtime by Strategy", y = "Total Runtime (sec)", x = NULL)

```



### capturing variants
```{r}


alignment_dir_ava <- 
  sprintf(
    "%s/all_vs_all", alignment_dir
  )
alignment_dir_rvq <- 
  sprintf(
    "%s/refs_vs_qrys", alignment_dir
  )
alignment_dir_1va <- 
  sprintf(
    "%s/one_vs_all", alignment_dir
  )

deltas_ava <- 
  All_vs_all_m %>%
  as_tibble %>%
    mutate(
        expected_basename = str_c(ref, "_v_", qry, "_filtered.delta")
    ) %>% 
    inner_join(
        ., 
        tibble(
            expected_basename =
              basename(list.files(alignment_dir_ava, full.names = T)),
            fullname = 
              list.files(alignment_dir_ava, full.names = T)
        ), 
        by = "expected_basename"
    ) %>%
    mutate(
        unfiltered_fullname = 
            sprintf(
                "%s/unfiltered/%s.delta",
                alignment_dir_ava,
                str_c(ref, "_v_", qry)
            )
    )
lapply(
  10:20,
  function(i){
  deltas_ava$fullname[i] %>% plot_delta
  }
)
deltas_ava$fullname[19] %>% plot_delta

#library(gridExtra)

do.call(grid.arrange, c(lapply(
  10:20,
  function(i){
  deltas_ava$fullname[i] %>% plot_delta
  }
), ncol = 2))

all_SVs <- 
    bind_rows(
        all_indels %>%
            ungroup %>%
            transmute(
                rid,qid, width, 
                start, end,
                refmid = round((start+end)/2),
                #indel_type = variant, 
                bin, 
                variant_specific = variant,
                variant = "Indel",
                species, idx
            ),
        all_dups %>%
            transmute(
                rid = ref_name, 
                qid = qry_name,
                width = dup_len,
                start = dup_s, end = dup_e,
                refmid = round((start+end)/2),
                bin, 
                variant_specific = 
                    ifelse(
                        duplication_type =="tandem",
                        duplication_type,
                        paste(
                            duplication_type, domains, sep = " "
                        )
                    ),
                variant = "Duplication",
                species , idx
            ),
        all_tlocs %>%
            ungroup %>%
            transmute(
                rid, qid, 
                width,
                start, end,
                refmid,
                bin, variant,
                variant_specific =
                    replichores,
                species, idx
            ),
        substruct_invs %>%
            ungroup() %>%
            transmute(
                rid, qid, 
                width = meanlen,
                start = rs, end = re, 
                refmid = round((rs+re)/2),
                bin, 
                variant_specific = 
                    variant,
                variant = "Inversion",
                species, idx
            )
    ) 


delta_file <- 
  deltas_ava$fullname[19]

unfiltered_delta_file <- 
  deltas_ava$unfiltered_fullname[19]

delta_all_SVs_prev <- 
  function(delta_file, unfiltered_delta_file){
    
    ### indels
    delta_indels_i <- 
      delta_indels(delta_i) %>%
      transmute(
          rid,qid, width, 
          start, end,
          refmid = round((start+end)/2),
          #indel_type = variant, 
          variant_specific = variant,
          variant = "Indel",
          species = species_name
      )
    if (nrow(delta_indels_i)==0){
      delta_indels_i <- 
        tibble(
          rid = delta_file$ref[i],
          qid = delta_file$qry[i],
          idx = 0
        )
    }
    ## duplications
    delta_dups_i <- 
      delta_duplications(
        delta_table = delta_file, 
        unfiltered_delta_table = unfiltered_delta_file
                ) 
    
    ## translocations
    
    delta_tlocs_i <- 
      delta_translocations(delta_file) %>%
      transmute(
        rid, qid, 
        width,
        start, end,
        refmid,
        variant,
        variant_specific =
          replichores,
        species = species_name
            )
    
    delta_SR_temp <- 
      delta_structural_rearrangements(delta_file)
    
    delta_subSR_i <- 
      delta_substructural_inversions(delta_file, delta_SR_temp) %>%
      ungroup() %>%
            transmute(
                rid, qid, 
                width = meanlen,
                start = rs, end = re, 
                refmid = round((rs+re)/2),
                variant_specific = 
                    variant,
                variant = "Inversion",
                species= species_name
            )
    
    delta_subSR_i %>% arrange(desc(width))
    
    delta_SR_i <- 
      delta_SR_temp %>%
      transmute(
        rid, qid, 
        width,
        start = rs, 
        end = re,
        refmid = round((rs+re)/2),
        variant = "Sructural rearrangement",
        variant_specific,
        species = species_name
            )
    
                
    
  }




delta_all_SVs <- 
  function(delta_file, unfiltered_delta_file, species_name){
  
  ### Indels
  delta_indels_i <- 
    delta_indels(delta_file) %>%
    transmute(
      rid, qid, width, 
      start, end,
      refmid = round((start + end) / 2),
      variant_specific = variant,
      variant = "Indel",
      species = species_name
    )
  
  if (nrow(delta_indels_i) == 0){
    delta_indels_i <- tibble(
      rid = character(),
      qid = character(),
      width = numeric(),
      start = numeric(),
      end = numeric(),
      refmid = numeric(),
      variant_specific = character(),
      variant = character(),
      species = character()
    )
  }

  ### Duplications
  delta_dups_i <- 
    delta_duplications(
    delta_table = delta_file, 
    unfiltered_delta_table = unfiltered_delta_file
  ) %>% 
    transmute(
      rid = ref_name, qid = qry_name,
      start = dup_ref_start,
      end = dup_ref_end,
      width = abs(end - start),
      refmid = round((start + end) / 2),
      variant_specific = duplication_type,
      variant = "Duplication",
      species = species_name
    )
  
  if (nrow(delta_dups_i) == 0){
    delta_dups_i <- delta_indels_i[0,]
  }

  ### Translocations
  delta_tlocs_i <- delta_translocations(delta_file) %>%
    transmute(
      rid, qid, width,
      start, end,
      refmid = round((start + end) / 2),
      variant_specific = replichores,
      variant = "Translocation",
      species = species_name
    )

  if (nrow(delta_tlocs_i) == 0){
    delta_tlocs_i <- delta_indels_i[0,]
  }

  ### Structural rearrangements
  delta_SR_temp <- delta_structural_rearrangements(delta_file)

  delta_subSR_i <- delta_substructural_inversions(delta_file, delta_SR_temp) %>%
    ungroup() %>%
    transmute(
      rid, qid,
      width = meanlen,
      start = rs, end = re,
      refmid = round((rs + re) / 2),
      variant_specific = variant,
      variant = "Inversion",
      species = species_name
    )

  if (nrow(delta_subSR_i) == 0){
    delta_subSR_i <- delta_indels_i[0,]
  }

  delta_SR_i <- delta_SR_temp %>%
    transmute(
      rid, qid,
      width,
      start = rs,
      end = re,
      refmid = round((rs + re) / 2),
      variant = "Structural rearrangement",
      variant_specific,
      species = species_name
    )

  if (nrow(delta_SR_i) == 0){
    delta_SR_i <- delta_indels_i[0,]
  }

  ### Combine all SVs
  all_SVs <- bind_rows(
    delta_indels_i,
    delta_dups_i,
    delta_tlocs_i,
    delta_subSR_i,
    delta_SR_i
  ) %>% arrange(desc(width))

  return(all_SVs)
}



all_indels <- 
    pbmclapply(
        1:nrow(deltas_ava),
        function(i){
            #for (i in 1:nrow(df_tib)){
            row_i <- 
                deltas_ava[i,]
            delta_i <- 
                row_i %>%
                pull(fullname)
            delta_indels_i <- 
                delta_indels(delta_i) %>%
                mutate(idx = i)
            
            if (nrow(delta_indels_i)==0){
                delta_indels_i <- 
                    tibble(
                        rid = deltas_ava$ref[i],
                        qid = deltas_ava$qry[i],
                        idx = i
                    )
                
            }
            return(delta_indels_i)
        }
    ) %>% 
    bind_rows %>%
    mutate(
        bin = 
            cut(
                width, 
                breaks = 
                    c(
                        50, 500, 1000, 
                        2000, 10000, Inf
                    ), 
                right = FALSE),
        species = species_name
    ) %>%
    rowwise() %>%
    mutate(rq = paste(rid, qid, sep ="_")) %>%
    group_by(bin, rq) %>%
    mutate(
        SV_count = n()
    )


all_dups <- 
    pbmclapply(
        1:nrow(df_tib),
        function(i){
            #for (i in 1:nrow(df_tib)){
            row_i <- 
                df_tib[i,]
            delta_i <- 
                row_i %>%
                pull(fullname)
            
            ufd_i <- 
                row_i %>%
                pull(unfiltered_fullname)
            
            delta_dups_i <- 
                delta_duplications(
                    delta_table = delta_i, 
                    unfiltered_delta_table = ufd_i
                ) 
            
            dd_check <- 
                ncol(delta_dups_i)
            
            delta_dups_i <- 
                delta_dups_i %>%
                mutate(
                    nr = 
                        ifelse(
                            dd_check==2,
                            0,
                            n()
                        ),
                    idx = i
                )
            
            if (nrow(delta_dups_i)==0){
                delta_dups_i <- 
                    tibble(
                        rid = df_tib$ref[i],
                        qid = df_tib$qry[i],
                        idx = i
                    )
                
               # print(i)}
                
            }
            return(delta_dups_i)
        }, mc.cores = 4
    ) %>% 
    bind_rows %>%
    mutate(
        bin = 
            cut(
                dup_len, 
                breaks = 
                    c(
                        50, 500, 1000, 
                        2000, 10000, Inf
                    ), 
                right = FALSE),
        species = species_name
    ) 





deltas_rvq



deltas_1va

```


## get all delta_files


### Arrange and align wrapper
```{r}

species_table

assembly_table


the_rest <- 
  species_table %>%
  filter(
    !(basename(ftp_path) %in% assembly_table$asm_name)
  )
  
ap_i <- 
  the_rest$ftp_path[1]


assembly_path <- 
  ap_i

ref_path <- 
  sprintf(
    "%s/%s.txt",
    sync_dir, most_related
  )

alignment_dir_the_rest <- 
  sprintf(
    "%s/1v_the_rest",
    alignment_dir
  )
sync_dir_the_rest <- 
  sprintf(
    "%s/1v_the_rest",
    sync_dir
  )

if (!dir.exists(alignment_dir_the_rest)){dir.create(alignment_dir_the_rest)}

if (!dir.exists(sync_dir_the_rest)){dir.create(sync_dir_the_rest)}

sync_dir
most_related

al_list <- 
  list()

al_list_head <- 
  bind_rows(al_list)

al_list_tail <- 
  pbmclapply(
    622:nrow(the_rest),
    function(i){
      assembly_path <- 
      the_rest$ftp_path[i]
    out_tib <- 
      arrange_align(
        assembly_path, 
        ref_path,
        alignment_dir_the_rest,
        sync_dir_the_rest
      )
      return(out_tib)
    },
    mc.cores = 4
  )

ori_positions_tib <- 
  bind_rows(
    al_list_head,
    bind_rows(al_list_tail)
  )



pb <- txtProgressBar(min = 431, max = nrow(the_rest), style = 3)
for (i in 431:nrow(the_rest)){
  assembly_path <- 
    the_rest$ftp_path[i]
  al_list[[i]] <- 
    arrange_align(
      assembly_path, 
      ref_path,
      alignment_dir_the_rest,
      sync_dir_the_rest
    )
  setTxtProgressBar(pb, i)
}
close(pb)


arrange_align <- 
  function(
    assembly_path,
    ref_path,
    alignment_dir_the_rest,
    sync_dir_the_rest
  ){
    
      fasta_path <- 
        sprintf(
          "%s/%s_genomic.fna.gz",
          assembly_path, 
          gsub(".*/", "", assembly_path)
          )
      
      gff_path <- 
        sprintf(
          "%s/%s_genomic.gff.gz",
          assembly_path,
          gsub(".*/", "", assembly_path)
          )
      
      fna_exists <- 
              file_exists_at_url(fasta_path)
      gff_exists <- 
              file_exists_at_url(gff_path)
      
      dnaA_table <- 
        dnaA_from_gff(
          gff_path
          )
      if (!fna_exists | !gff_exists){
        position_tib <- 
          tibble( 
            asm_name = 
              basename(assembly_path),
            note = "missing fasta/gff"
                  )
      } else {
        position_tib <-   
          dnaA_sync(fasta_path, dnaA_table, sync_dir_the_rest)
      }
      
      
      ## align to the ref
      simple_nucmer(
        ref = ref_path, 
        qry = position_tib$out_file,
        output = 
          sprintf(
            "%s_v_%s",
            sub(".txt", "", basename(ref_path)), 
            sub(".txt", "", basename(position_tib$out_file))
          ),
        alignment_dir = alignment_dir_the_rest
      ) %>% system()
      
      
      out_tib <- 
        position_tib 
      
      file.remove(position_tib$out_file)
      
      return(position_tib)
  }

system("nucmer --mum --maxgap=500 --mincluster=100 --prefix=NZ_CP148880.1_v_NZ_CP030207.1 processing/sync/Gamma/Salmonella_enterica/NZ_CP148880.1.txt processing/sync/Gamma/Salmonella_enterica/1v_the_rest/NZ_CP030207.1.txt")

readDNAStringSet("processing/sync/Gamma/Salmonella_enterica/NZ_CP148880.1.txt")

all_delta_filt_files <- 
  c(
    list.files(
      sprintf(
        "%s/1v_the_rest",
        alignment_dir
        ),
      full.names = T, pattern = "filtered"
    ),
    list.files(
      sprintf(
        "%s/one_vs_all",
        alignment_dir
        ),
      full.names = T, pattern = "filtered"
    )
  )

all_delta_unfilt_files <- 
  c(
    list.files(
      sprintf(
        "%s/1v_the_rest/unfiltered",
        alignment_dir
        ),
      full.names = T
    ),
    list.files(
      sprintf(
        "%s/one_vs_all/unfiltered",
        alignment_dir
        ),
      full.names = T
    )
  )
head(all_delta_filt_files)
head(all_delta_unfilt_files)
length(all_delta_files)





## capture variants


library(tools)

filt_basenames  <- basename(all_delta_filt_files)
filt_core_names <- sub("_filtered\\.delta$", "", filt_basenames)

unfilt_basenames  <- basename(all_delta_unfilt_files)
unfilt_core_names <- sub("\\.delta$", "", unfilt_basenames)

# Create a named vector to easily look up unfiltered files by core name
unfilt_lookup <- setNames(all_delta_unfilt_files, unfilt_core_names)

n <- length(all_delta_filt_files)
all_results <- vector("list", n)

pb <- txtProgressBar(min = 188, max = n, style = 3)

for (i in 188:n) {
  core_name <- filt_core_names[i]
  filtered_delta <- all_delta_filt_files[i]
  
  if (!core_name %in% names(unfilt_lookup)) {
    warning(sprintf("No unfiltered file found for %s, skipping...", filtered_delta))
    next
  }
  unfiltered_delta <- unfilt_lookup[[core_name]]
  species_name <- "Salmonella_enterica" # change as needed
  
  all_results[[i]] <- 
    delta_all_SVs(
    delta_file = filtered_delta, 
    unfiltered_delta_file = unfiltered_delta,
    species_name = species_name
  )
  
  setTxtProgressBar(pb, i)
}

close(pb)






# Optionally remove NULL or empty results if any files were skipped
all_SV_results <- 
  bind_rows(Filter(Negate(is.null), all_results))

```




## translocations 
```{r}
all_SV_results %>% filter(variant=="Translocation") %>% count()


summarize_translocation <- function(from, to) {
  if (from == to) {
    return(paste0("within_", from))
  }
  # Define adjacent pairs (circular: O-L-T-R-O)
  adjacent_pairs <- list(
    c("O", "L"), c("L", "T"), c("T", "R"), c("R", "O")
  )
  if (any(sapply(adjacent_pairs, function(pair) all(c(from, to) %in% pair)))) {
    return(paste0("adjacent_", from, "_", to))
  }
  # The rest are "across"
  return(paste0("across_", from, "_", to))
}

tloc_categories <- 
  all_SV_results %>%
  filter(variant=="Translocation") %>%
  mutate(
    from = substr(variant_specific, 1, 1),
    to = substr(variant_specific, 3, 3),
    tloc_category = mapply(summarize_translocation, from, to),
    tloc_broad = 
      case_when(
        grepl("^within_", tloc_category) ~ "Within",
        grepl("^adjacent_", tloc_category) ~ "Adjacent",
        grepl("^across_", tloc_category) ~ "Across",
        TRUE ~ NA_character_
    )
  )
  

ggplot(tloc_categories, aes(x = tloc_broad, fill = tloc_broad)) +
  geom_bar(show.legend = FALSE) +
  theme_classic(base_size = 15) +
  labs(
    title = "Translocation Events by Broad Category",
    x = "Category",
    y = "Count"
  )
  
ggplot(tloc_categories, aes(x = tloc_category, fill = tloc_broad)) +
  geom_bar() +
  scale_fill_brewer(palette = "Set1") +
  theme_classic(base_size = 15) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 11)) +
  labs(
    title = "Translocation Events by Detailed Category",
    x = "Translocation Category",
    y = "Count",
    fill = "Broad Class"
  )


ggplot(tloc_categories, aes(x = tloc_broad, y = width, fill = tloc_broad)) +
  geom_violin(show.legend = FALSE) +
  scale_y_log10() +
  theme_classic(base_size = 15) +
  labs(
    title = "SV Lengths by Broad Translocation Category",
    x = "Category",
    y = "SV Length (log10 bp)"
  )

```




```{r}


all_SV_results %>%
  count(variant, variant_specific, sort = TRUE)
sv_per_pair <- 
  all_SV_results %>%
  group_by(rid, qid, species) %>%
  summarise(n_SVs = n(), 
            .groups = "drop") %>%
  arrange(desc(n_SVs))

# View top and bottom genome pairs by SV count
head(sv_per_pair, 10)
tail(sv_per_pair, 10)

# Plot: SV count distribution per genome-pair
ggplot(sv_per_pair, aes(x = n_SVs)) +
  geom_histogram(binwidth = 5, fill = "#2171b5") +
  theme_classic() +
  labs(title = "SVs per Genome Pair",
       x = "Number of SVs",
       y = "Number of pairs")


ggplot(all_SV_results, aes(x = variant, y = width)) +
  geom_violin(aes(fill = variant), scale = "width", alpha = 0.8) +
  scale_y_log10() +
  theme_classic() +
  labs(title = "SV Size Distribution by Type",
       x = "SV Type", y = "Width (bp, log scale)")

# If you want to facet by variant_specific
ggplot(all_SV_results, aes(x = variant_specific, y = width, fill = variant)) +
  geom_violin(scale = "width", alpha = 0.8) +
  scale_y_log10() +
  facet_wrap(~variant, scales = "free_x") +
  theme_classic() +
  labs(title = "SV Size Distribution by Specific Class",
       x = "SV Subtype", y = "Width (bp, log scale)")



```



```{r}

```




